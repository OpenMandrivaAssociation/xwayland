From 070abe64b15db831802a842aa1965403eb24679e Mon Sep 17 00:00:00 2001
From: Olivier Fourdan <ofourdan@redhat.com>
Date: Wed, 31 Mar 2021 09:49:35 +0200
Subject: [PATCH xserver 10/27] xwayland/eglstream: Check framebuffer status
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The EGLStream backend would sometime generate GL errors trying to draw
to the framebuffer, which gives an invalid buffer, which in turn would
generate a Wayland error from the compositor which is fatal to the
client.

Check the framebuffer status and bail out early if it's not complete,
to avoid getting into trouble later.

Signed-off-by: Olivier Fourdan <ofourdan@redhat.com>
Reviewed-by: Michel DÃ¤nzer <mdaenzer@redhat.com>
https://gitlab.freedesktop.org/xorg/xserver/-/issues/1156
(cherry picked from commit 85244d2a2081d61a2e4a06e847041f638de01e3f)
---
 hw/xwayland/xwayland-glamor-eglstream.c | 18 ++++++++++++++----
 1 file changed, 14 insertions(+), 4 deletions(-)

diff --git a/hw/xwayland/xwayland-glamor-eglstream.c b/hw/xwayland/xwayland-glamor-eglstream.c
index f64d05064..64fe93b7c 100644
--- a/hw/xwayland/xwayland-glamor-eglstream.c
+++ b/hw/xwayland/xwayland-glamor-eglstream.c
@@ -619,6 +619,7 @@ xwl_glamor_eglstream_post_damage(struct xwl_window *xwl_window,
         box->x2 - box->x1, box->y2 - box->y1
     };
     GLint saved_vao;
+    int status;
 
     if (xwl_pixmap->type != XWL_PIXMAP_EGLSTREAM)
         /* This can happen if a client does X11 rendering on a
@@ -652,6 +653,13 @@ xwl_glamor_eglstream_post_damage(struct xwl_window *xwl_window,
     glUniform1i(xwl_eglstream->blit_is_rgba_pos,
                 pixmap->drawable.depth >= 32);
 
+    status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
+    if (status != GL_FRAMEBUFFER_COMPLETE) {
+        ErrorF("eglstream: Framebuffer incomplete 0x%X, not posting damage\n", status);
+        status = FALSE;
+        goto out;
+    }
+
     /* Blit rendered image into EGLStream surface */
     glDrawBuffer(GL_BACK);
     glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
@@ -662,14 +670,16 @@ xwl_glamor_eglstream_post_damage(struct xwl_window *xwl_window,
     else
         eglSwapBuffers(xwl_screen->egl_display, xwl_pixmap->surface);
 
+    /* hang onto the pixmap until the compositor has released it */
+    pixmap->refcnt++;
+    status = TRUE;
+
+out:
     /* Restore previous state */
     glBindVertexArray(saved_vao);
     glBindTexture(GL_TEXTURE_2D, 0);
 
-    /* hang onto the pixmap until the compositor has released it */
-    pixmap->refcnt++;
-
-    return TRUE;
+    return status;
 }
 
 static Bool
-- 
2.31.1

